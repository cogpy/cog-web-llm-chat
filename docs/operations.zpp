â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ WebLLM Chat - Operations Specification (Z++)                                â”‚
â”‚ Formal specification of system operations and state transitions             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
SECTION 1: CHAT SESSION OPERATIONS
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

â”Œâ”€ CreateNewSession â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Creates a new chat session                                                  â”‚
â”‚ Pre: System is initialized                                                  â”‚
â”‚ Post: New session added to sessions list                                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

[CreateNewSession]
  Î”ChatStore
  template?: Template
  
  -- Preconditions
  length(sessions) < MAX_SESSIONS
  
  -- Operation
  let newSession = ChatSession where
    newSession.id = fresh_id()
    newSession.topic = DEFAULT_TOPIC
    newSession.messages = âŸ¨âŸ©
    newSession.stat.tokenCount = 0
    newSession.stat.wordCount = 0
    newSession.stat.charCount = 0
    newSession.lastUpdate = current_time()
    newSession.lastSummarizeIndex = 0
    newSession.isGenerating = false
    newSession.template = template âˆ¨ createEmptyTemplate()
  
  -- Postconditions
  sessions' = sessions âŒ¢ âŸ¨newSessionâŸ©
  currentSessionIndex' = length(sessions)
  
  length(sessions') = length(sessions) + 1

â”Œâ”€ DeleteSession â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Deletes a chat session                                                      â”‚
â”‚ Pre: Session exists and is not the only session                             â”‚
â”‚ Post: Session removed, current index adjusted                               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

[DeleteSession]
  Î”ChatStore
  sessionId: seq char
  
  -- Preconditions
  âˆƒ i: â„• â€¢ i < length(sessions) âˆ§ sessions[i].id = sessionId
  length(sessions) > 1
  
  -- Operation
  let index = find_session_index(sessionId)
  
  -- Postconditions
  sessions' = remove_at(sessions, index)
  
  currentSessionIndex' = 
    if index < currentSessionIndex then
      currentSessionIndex - 1
    else if index = currentSessionIndex âˆ§ index = length(sessions) - 1 then
      currentSessionIndex - 1
    else
      currentSessionIndex
  
  length(sessions') = length(sessions) - 1

â”Œâ”€ SendMessage â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Adds a user message to the current session                                  â”‚
â”‚ Pre: Session is not generating, content is non-empty                        â”‚
â”‚ Post: Message added, session updated                                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

[SendMessage]
  Î”ChatStore
  content: seq char âˆª seq MultimodalContent
  
  -- Preconditions
  sessions[currentSessionIndex].isGenerating = false
  length(content) > 0
  
  -- Operation
  let message = ChatMessage where
    message.id = fresh_id()
    message.role = user
    message.content = content
    message.date = current_date_string()
    message.streaming = false
    message.isError = false
  
  let session = sessions[currentSessionIndex]
  
  -- Postconditions
  sessions'[currentSessionIndex].messages = session.messages âŒ¢ âŸ¨messageâŸ©
  sessions'[currentSessionIndex].lastUpdate = current_time()
  sessions'[currentSessionIndex].stat = update_stats(session.stat, message)
  
  âˆ€ i: â„• â€¢ i â‰  currentSessionIndex âŸ¹ sessions'[i] = sessions[i]

â”Œâ”€ StreamAssistantMessage â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Streams an assistant response (incremental updates)                         â”‚
â”‚ Pre: Session is not generating or has streaming message                     â”‚
â”‚ Post: Message created or updated with new chunk                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

[StreamAssistantMessage]
  Î”ChatStore
  chunk: seq char
  
  -- Preconditions
  let session = sessions[currentSessionIndex]
  
  -- Operation (two cases)
  
  -- Case 1: Start new streaming message
  (session.isGenerating = false âŸ¹
    let message = ChatMessage where
      message.id = fresh_id()
      message.role = assistant
      message.content = chunk
      message.date = current_date_string()
      message.streaming = true
      message.isError = false
    
    sessions'[currentSessionIndex].messages = session.messages âŒ¢ âŸ¨messageâŸ©
    sessions'[currentSessionIndex].isGenerating = true)
  
  -- Case 2: Update existing streaming message
  âˆ¨
  (session.isGenerating = true âŸ¹
    let lastMsg = last(session.messages)
    lastMsg.streaming = true
    
    sessions'[currentSessionIndex].messages = 
      init(session.messages) âŒ¢ âŸ¨lastMsg with content := lastMsg.content âŒ¢ chunkâŸ©)
  
  -- Postconditions
  sessions'[currentSessionIndex].lastUpdate = current_time()

â”Œâ”€ CompleteAssistantMessage â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Finalizes streaming assistant message                                       â”‚
â”‚ Pre: Session is generating                                                  â”‚
â”‚ Post: Message marked complete, generation stopped                           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

[CompleteAssistantMessage]
  Î”ChatStore
  stopReason: ChatCompletionFinishReason
  usage?: CompletionUsage
  model: Model
  
  -- Preconditions
  sessions[currentSessionIndex].isGenerating = true
  
  -- Operation
  let session = sessions[currentSessionIndex]
  let lastMsg = last(session.messages)
  
  let completedMsg = lastMsg where
    streaming = false
    stopReason = stopReason
    usage = usage
    model = model
  
  -- Postconditions
  sessions'[currentSessionIndex].messages = 
    init(session.messages) âŒ¢ âŸ¨completedMsgâŸ©
  sessions'[currentSessionIndex].isGenerating = false
  sessions'[currentSessionIndex].lastUpdate = current_time()
  sessions'[currentSessionIndex].stat = update_stats(session.stat, completedMsg)

â”Œâ”€ UpdateSessionTopic â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Updates the topic/title of a session                                        â”‚
â”‚ Pre: Session exists                                                         â”‚
â”‚ Post: Session topic updated                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

[UpdateSessionTopic]
  Î”ChatStore
  sessionId: seq char
  newTopic: seq char
  
  -- Preconditions
  âˆƒ i: â„• â€¢ i < length(sessions) âˆ§ sessions[i].id = sessionId
  length(newTopic) > 0
  
  -- Operation
  let index = find_session_index(sessionId)
  
  -- Postconditions
  sessions'[index].topic = newTopic
  sessions'[index].lastUpdate = current_time()
  
  âˆ€ i: â„• â€¢ i â‰  index âŸ¹ sessions'[i] = sessions[i]

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
SECTION 2: CONFIGURATION OPERATIONS
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

â”Œâ”€ UpdateModelConfig â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Updates model configuration parameters                                      â”‚
â”‚ Pre: New config is valid                                                    â”‚
â”‚ Post: Config updated with new values                                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

[UpdateModelConfig]
  Î”ConfigStore
  newConfig: ModelConfig
  
  -- Preconditions
  valid_model(newConfig.model)
  0.0 â‰¤ newConfig.temperature â‰¤ 2.0
  0.0 â‰¤ newConfig.top_p â‰¤ 1.0
  0 < newConfig.max_tokens â‰¤ newConfig.context_window_size
  
  -- Operation & Postconditions
  config'.modelConfig = newConfig
  config'.lastUpdate = current_time()
  
  -- Preserve other config fields
  config'.submitKey = config.submitKey
  config'.theme = config.theme
  -- ... (other fields unchanged)

â”Œâ”€ SwitchModelClient â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Switches between WebLLM and MLC-LLM API clients                             â”‚
â”‚ Pre: Client type is valid, required config exists                           â”‚
â”‚ Post: Client type changed, related config validated                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

[SwitchModelClient]
  Î”ConfigStore
  Î”WebLLMState
  Î”MLCLLMState
  newClientType: ModelClient
  
  -- Preconditions
  newClientType âˆˆ {WEBLLM, MLCLLM_API}
  
  newClientType = MLCLLM_API âŸ¹ 
    length(config.modelConfig.mlc_endpoint) > 0 âˆ§
    is_valid_url(config.modelConfig.mlc_endpoint)
  
  -- Operation
  config'.modelClientType = newClientType
  config'.lastUpdate = current_time()
  
  -- Side effects on client states
  (newClientType = WEBLLM âŸ¹
    webllmState'.initialized = false âˆ§
    mlcllmState'.connected = false)
  
  âˆ¨
  (newClientType = MLCLLM_API âŸ¹
    webllmState'.isGenerating = false âˆ§
    mlcllmState'.endpoint = config.modelConfig.mlc_endpoint)

â”Œâ”€ UpdateTheme â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Changes the UI theme                                                        â”‚
â”‚ Pre: Theme is valid                                                         â”‚
â”‚ Post: Theme updated                                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

[UpdateTheme]
  Î”ConfigStore
  newTheme: Theme
  
  -- Preconditions
  newTheme âˆˆ {Auto, Dark, Light}
  
  -- Postconditions
  config'.theme = newTheme
  config'.lastUpdate = current_time()
  
  -- All other fields unchanged
  config'.modelConfig = config.modelConfig
  config'.submitKey = config.submitKey
  -- ...

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
SECTION 3: MULTI-AGENT OPERATIONS
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

â”Œâ”€ RegisterAgent â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Registers a new agent in the orchestration system                           â”‚
â”‚ Pre: Agent ID is unique                                                     â”‚
â”‚ Post: Agent added to registry                                               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

[RegisterAgent]
  Î”OrchestrationState
  agent: Agent
  
  -- Preconditions
  agent.id âˆ‰ dom agents
  length(agent.name) > 0
  length(agent.capabilities) > 0
  
  -- Postconditions
  agents' = agents âˆª {agent.id â†¦ agent}
  
  -- Message queue and tasks unchanged
  messageQueue' = messageQueue
  tasks' = tasks
  activeSession' = activeSession

â”Œâ”€ UnregisterAgent â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Removes an agent from the system                                            â”‚
â”‚ Pre: Agent exists and has no assigned tasks                                 â”‚
â”‚ Post: Agent removed, status set to offline                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

[UnregisterAgent]
  Î”OrchestrationState
  agentId: seq char
  
  -- Preconditions
  agentId âˆˆ dom agents
  âˆ€ t: Task â€¢ t âˆˆ ran tasks âŸ¹ 
    t.assignedTo â‰  agentId âˆ¨ t.status âˆˆ {COMPLETED, FAILED, CANCELLED}
  
  -- Operation
  let agent = agents(agentId) with status := OFFLINE
  
  -- Postconditions
  agents' = {id â†¦ a | id â†¦ a âˆˆ agents âˆ§ id â‰  agentId}
  
  -- Remove messages involving this agent
  messageQueue' = {m | m âˆˆ messageQueue âˆ§ 
    m.senderId â‰  agentId âˆ§ m.receiverId â‰  agentId}

â”Œâ”€ CreateTask â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Creates a new task for agent execution                                      â”‚
â”‚ Pre: Description is non-empty                                               â”‚
â”‚ Post: Task added to task registry                                           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

[CreateTask]
  Î”OrchestrationState
  description: seq char
  priority: â„•
  dependencies?: seq (seq char)
  
  -- Preconditions
  length(description) > 0
  1 â‰¤ priority â‰¤ 10
  
  dependencies â‰  null âŸ¹ 
    âˆ€ dep: seq char â€¢ dep âˆˆ dependencies âŸ¹ dep âˆˆ dom tasks
  
  -- Operation
  let task = Task where
    task.id = fresh_id()
    task.description = description
    task.status = PENDING
    task.priority = priority
    task.dependencies = dependencies âˆ¨ âŸ¨âŸ©
    task.createdAt = current_time()
    task.updatedAt = current_time()
  
  -- Postconditions
  tasks' = tasks âˆª {task.id â†¦ task}
  
  -- Check for dependency cycles
  task.id âˆ‰ transitive_task_dependencies(task.id)

â”Œâ”€ AssignTask â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Assigns a task to a specific agent                                          â”‚
â”‚ Pre: Task exists, agent exists and has capability, dependencies met         â”‚
â”‚ Post: Task assigned, agent status updated, message sent                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

[AssignTask]
  Î”OrchestrationState
  taskId: seq char
  agentId: seq char
  
  -- Preconditions
  taskId âˆˆ dom tasks
  agentId âˆˆ dom agents
  
  let task = tasks(taskId)
  let agent = agents(agentId)
  
  task.status = PENDING
  agent.status âˆˆ {IDLE, BUSY}
  
  -- Agent has required capability
  âˆƒ cap: seq char â€¢ cap âˆˆ agent.capabilities âˆ§ 
    requires_capability(task.description, cap)
  
  -- Dependencies are completed
  âˆ€ dep: seq char â€¢ dep âˆˆ task.dependencies âŸ¹ 
    tasks(dep).status = COMPLETED
  
  -- Operation
  let updatedTask = task where
    assignedTo = agentId
    status = ASSIGNED
    updatedAt = current_time()
  
  let updatedAgent = agent where
    status = BUSY
  
  let taskMessage = AgentMessage where
    id = fresh_id()
    senderId = "orchestrator"
    receiverId = agentId
    content = task.description
    timestamp = current_time()
    type = TASK
    metadata = {taskId â†¦ taskId}
  
  -- Postconditions
  tasks' = tasks âŠ• {taskId â†¦ updatedTask}
  agents' = agents âŠ• {agentId â†¦ updatedAgent}
  messageQueue' = messageQueue âŒ¢ âŸ¨taskMessageâŸ©

â”Œâ”€ CompleteTask â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Marks a task as completed with result                                       â”‚
â”‚ Pre: Task is in progress                                                    â”‚
â”‚ Post: Task completed, agent status updated                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

[CompleteTask]
  Î”OrchestrationState
  taskId: seq char
  result: any
  
  -- Preconditions
  taskId âˆˆ dom tasks
  
  let task = tasks(taskId)
  task.status = IN_PROGRESS
  task.assignedTo â‰  ""
  
  -- Operation
  let updatedTask = task where
    status = COMPLETED
    result = result
    updatedAt = current_time()
  
  let agentId = task.assignedTo
  let updatedAgent = agents(agentId) where
    status = IDLE
  
  -- Postconditions
  tasks' = tasks âŠ• {taskId â†¦ updatedTask}
  agents' = agents âŠ• {agentId â†¦ updatedAgent}

â”Œâ”€ SendAgentMessage â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Sends a message from one agent to another (or broadcast)                    â”‚
â”‚ Pre: Sender exists, receiver exists (unless broadcast)                      â”‚
â”‚ Post: Message added to queue                                                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

[SendAgentMessage]
  Î”OrchestrationState
  senderId: seq char
  receiverId?: seq char
  content: seq char
  msgType: MessageType
  
  -- Preconditions
  senderId âˆˆ dom agents
  length(content) > 0
  
  msgType â‰  BROADCAST âŸ¹ 
    receiverId â‰  null âˆ§ receiverId âˆˆ dom agents
  
  -- Operation
  let message = AgentMessage where
    id = fresh_id()
    senderId = senderId
    receiverId = receiverId âˆ¨ ""
    content = content
    timestamp = current_time()
    type = msgType
  
  -- Postconditions
  messageQueue' = messageQueue âŒ¢ âŸ¨messageâŸ©
  
  -- Agents and tasks unchanged
  agents' = agents
  tasks' = tasks

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
SECTION 4: KNOWLEDGE REPRESENTATION OPERATIONS
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

â”Œâ”€ AddAtom â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Adds an atom to the AtomSpace                                               â”‚
â”‚ Pre: Atom is well-formed                                                    â”‚
â”‚ Post: Atom added, index updated                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

[AddAtom]
  Î”AtomSpace
  atom: AtomNode
  
  -- Preconditions
  is_well_formed_atom(atom)
  
  -- No cyclic references in children
  âˆ€ c: AtomNode â€¢ c âˆˆ atom.children âŸ¹ 
    atom âˆ‰ transitive_children(c)
  
  -- Operation & Postconditions
  atoms' = atoms âŒ¢ âŸ¨atomâŸ©
  
  -- Update index if atom has a name
  atom.name â‰  "" âŸ¹ 
    atomIndex' = atomIndex âˆª {atom.name â†¦ length(atoms)}
  
  atom.name = "" âŸ¹ 
    atomIndex' = atomIndex

â”Œâ”€ QueryAtomSpace â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Queries the AtomSpace for matching atoms                                    â”‚
â”‚ Pre: Query pattern is valid                                                 â”‚
â”‚ Post: Returns matching atoms (read-only operation)                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

[QueryAtomSpace]
  ÎAtomSpace
  pattern: AtomNode
  result!: seq AtomNode
  
  -- Preconditions
  is_well_formed_atom(pattern)
  
  -- Operation
  result! = {a | a âˆˆ atoms âˆ§ matches_pattern(a, pattern)}
  
  -- State unchanged (read-only)

â”Œâ”€ UpdateTruthValue â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Updates the truth value of an atom                                          â”‚
â”‚ Pre: Atom exists, truth value is valid                                      â”‚
â”‚ Post: Atom truth value updated                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

[UpdateTruthValue]
  Î”AtomSpace
  atomName: seq char
  newTruthValue: TruthValue
  
  -- Preconditions
  atomName âˆˆ dom atomIndex
  0.0 â‰¤ newTruthValue.strength â‰¤ 1.0
  0.0 â‰¤ newTruthValue.confidence â‰¤ 1.0
  
  -- Operation
  let index = atomIndex(atomName)
  let atom = atoms[index]
  
  -- Postconditions
  atoms'[index] = atom with truthValue := newTruthValue
  
  âˆ€ i: â„• â€¢ i â‰  index âŸ¹ atoms'[i] = atoms[i]
  atomIndex' = atomIndex

â”Œâ”€ TranslateToAtomese â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Translates natural language or MeTTa to Atomese                             â”‚
â”‚ Pre: Input is non-empty, source format is valid                             â”‚
â”‚ Post: Returns Atomese representation                                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

[TranslateToAtomese]
  request: TranslationRequest
  response!: TranslationResponse
  
  -- Preconditions
  length(request.input) > 0
  request.sourceFormat âˆˆ {NATURAL_LANGUAGE, METTA}
  request.targetFormat = ATOMESE
  
  -- Operation (abstract - implementation uses LLM or rule-based translation)
  let atomese_output = translate(request.input, request.sourceFormat, ATOMESE)
  
  -- Postconditions
  response!.output = atomese_output
  response!.sourceFormat = request.sourceFormat
  response!.targetFormat = ATOMESE
  0.0 â‰¤ response!.confidence â‰¤ 1.0

â”Œâ”€ TranslateToMeTTa â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Translates natural language or Atomese to MeTTa                             â”‚
â”‚ Pre: Input is non-empty, source format is valid                             â”‚
â”‚ Post: Returns MeTTa representation                                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

[TranslateToMeTTa]
  request: TranslationRequest
  response!: TranslationResponse
  
  -- Preconditions
  length(request.input) > 0
  request.sourceFormat âˆˆ {NATURAL_LANGUAGE, ATOMESE}
  request.targetFormat = METTA
  
  -- Operation
  let metta_output = translate(request.input, request.sourceFormat, METTA)
  
  -- Postconditions
  response!.output = metta_output
  response!.sourceFormat = request.sourceFormat
  response!.targetFormat = METTA
  0.0 â‰¤ response!.confidence â‰¤ 1.0

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
SECTION 5: REASONING OPERATIONS
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

â”Œâ”€ ApplyPLNRule â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Applies a PLN inference rule (deduction, induction, abduction)              â”‚
â”‚ Pre: Premises exist in AtomSpace, rule is applicable                        â”‚
â”‚ Post: Conclusion added to AtomSpace with computed truth value               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

[ApplyPLNRule]
  Î”AtomSpace
  Î”PLNState
  ruleName: {deduction, induction, abduction, bayes}
  premise1: AtomNode
  premise2: AtomNode
  
  -- Preconditions
  premise1 âˆˆ atoms
  premise2 âˆˆ atoms
  is_applicable(ruleName, premise1, premise2)
  
  -- Operation
  let conclusion = apply_rule(ruleName, premise1, premise2)
  let conclusionTV = compute_truth_value(ruleName, premise1.truthValue, premise2.truthValue)
  
  conclusion.truthValue = conclusionTV
  
  -- Postconditions
  atoms' = atoms âŒ¢ âŸ¨conclusionâŸ©
  inferenceHistory' = inferenceHistory âŒ¢ âŸ¨(premise1, premise2, conclusion)âŸ©
  ruleApplications' = ruleApplications + 1
  averageConfidence' = 
    (averageConfidence Ã— ruleApplications + conclusionTV.confidence) / ruleApplications'

â”Œâ”€ UpdateSTI â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Updates short-term importance (attention) for an atom                       â”‚
â”‚ Pre: Atom exists, STI delta preserves conservation                          â”‚
â”‚ Post: STI updated, conservation maintained                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

[UpdateSTI]
  Î”ECANState
  atomName: seq char
  stiDelta: â„¤
  
  -- Preconditions
  atomName âˆˆ dom atomSTI
  
  let newSTI = atomSTI(atomName) + stiDelta
  MIN_STI â‰¤ newSTI â‰¤ MAX_STI
  
  -- Conservation: total STI remains constant (other atoms adjusted)
  
  -- Postconditions
  atomSTI' = atomSTI âŠ• {atomName â†¦ newSTI}
  totalSTI' = totalSTI  -- Conservation law
  
  -- Update attentional focus
  newSTI > ATTENTION_THRESHOLD âŸ¹ 
    attentionalFocus' = attentionalFocus âˆª {atomName}
  
  newSTI â‰¤ ATTENTION_THRESHOLD âŸ¹ 
    attentionalFocus' = attentionalFocus \ {atomName}

â”Œâ”€ ForgettingProcess â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Implements forgetting: low-STI atoms lose importance over time              â”‚
â”‚ Pre: ECAN state exists                                                      â”‚
â”‚ Post: STI values decayed, some atoms may be removed                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

[ForgettingProcess]
  Î”ECANState
  Î”AtomSpace
  decayFactor: â„
  
  -- Preconditions
  0.0 < decayFactor < 1.0
  
  -- Operation: decay STI for atoms below threshold
  âˆ€ name: seq char â€¢ name âˆˆ dom atomSTI âˆ§ atomSTI(name) < ATTENTION_THRESHOLD âŸ¹
    atomSTI'(name) = âŒŠatomSTI(name) Ã— decayFactorâŒ‹
  
  -- Remove atoms with STI below minimum
  let forgotten = {name | name âˆˆ dom atomSTI âˆ§ atomSTI'(name) < MIN_STI}
  
  -- Postconditions
  atomSTI' = {name â†¦ sti | name â†¦ sti âˆˆ atomSTI âˆ§ name âˆ‰ forgotten}
  atoms' = {a | a âˆˆ atoms âˆ§ a.name âˆ‰ forgotten}
  
  totalSTI' = totalSTI  -- Conservation maintained

â”Œâ”€ MOSESGenerate â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Generates new candidate programs through crossover and mutation             â”‚
â”‚ Pre: Population exists                                                      â”‚
â”‚ Post: New generation created, best fitness tracked                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

[MOSESGenerate]
  Î”MOSESState
  crossoverRate: â„
  mutationRate: â„
  
  -- Preconditions
  length(population) > 0
  0.0 â‰¤ crossoverRate â‰¤ 1.0
  0.0 â‰¤ mutationRate â‰¤ 1.0
  
  -- Operation
  let parents = select_parents(population)  -- Based on fitness
  let offspring = crossover(parents, crossoverRate)
  let mutated = mutate(offspring, mutationRate)
  let evaluated = evaluate_fitness(mutated)
  
  -- Postconditions
  population' = select_survivors(population âˆª evaluated)
  generation' = generation + 1
  bestFitness' = max{f | (_, f) âˆˆ population'}
  averageFitness' = (Î£{f | (_, f) âˆˆ population'}) / length(population')

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
SECTION 6: MEMORY OPERATIONS
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

â”Œâ”€ StoreMemory â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Stores a new memory in short-term memory                                    â”‚
â”‚ Pre: Content is non-empty                                                   â”‚
â”‚ Post: Memory added to STM, capacity maintained                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

[StoreMemory]
  Î”PersistentMemoryState
  content: seq char
  importance: â„
  
  -- Preconditions
  length(content) > 0
  0.0 â‰¤ importance â‰¤ 1.0
  
  -- Operation
  let memory = MemoryEntry where
    id = fresh_id()
    content = content
    importance = importance
    timestamp = current_time()
    accessCount = 0
    lastAccessed = current_time()
  
  -- Postconditions
  -- If STM at capacity, remove oldest low-importance memory
  length(shortTermMemory) = STM_CAPACITY âŸ¹
    let oldest = find_oldest_low_importance(shortTermMemory)
    shortTermMemory' = remove(shortTermMemory, oldest) âŒ¢ âŸ¨memoryâŸ©
  
  length(shortTermMemory) < STM_CAPACITY âŸ¹
    shortTermMemory' = shortTermMemory âŒ¢ âŸ¨memoryâŸ©
  
  memoryIndex' = memoryIndex âˆª {memory.id â†¦ position(memory, shortTermMemory')}

â”Œâ”€ ConsolidateMemory â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Moves important memories from STM to LTM                                    â”‚
â”‚ Pre: STM has memories above importance threshold                            â”‚
â”‚ Post: Important memories moved to LTM                                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

[ConsolidateMemory]
  Î”PersistentMemoryState
  
  -- Operation
  let toConsolidate = {m | m âˆˆ shortTermMemory âˆ§ 
    (m.importance â‰¥ LTM_IMPORTANCE_THRESHOLD âˆ¨ 
     m.accessCount â‰¥ LTM_ACCESS_THRESHOLD)}
  
  -- Postconditions
  longTermMemory' = longTermMemory âˆª toConsolidate
  shortTermMemory' = shortTermMemory \ toConsolidate
  
  -- Update indices
  âˆ€ m: MemoryEntry â€¢ m âˆˆ toConsolidate âŸ¹
    memoryIndex'(m.id) = position(m, longTermMemory')

â”Œâ”€ RecallMemory â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Retrieves memories matching a query (read-only)                             â”‚
â”‚ Pre: Query is non-empty                                                     â”‚
â”‚ Post: Returns matching memories, updates access counts                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

[RecallMemory]
  Î”PersistentMemoryState
  query: seq char
  result!: seq MemoryEntry
  
  -- Preconditions
  length(query) > 0
  
  -- Operation
  let allMemories = shortTermMemory âˆª longTermMemory
  result! = {m | m âˆˆ allMemories âˆ§ matches_query(m.content, query)}
  
  -- Postconditions: Update access counts and timestamps
  âˆ€ m: MemoryEntry â€¢ m âˆˆ result! âŸ¹
    m'.accessCount = m.accessCount + 1 âˆ§
    m'.lastAccessed = current_time()

â”Œâ”€ RecordExperience â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Records an experience for agent learning                                    â”‚
â”‚ Pre: Agent exists, description is non-empty                                 â”‚
â”‚ Post: Experience added to agent's learning state                            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

[RecordExperience]
  Î”AgentLearningState
  description: seq char
  reward: â„
  
  -- Preconditions
  length(description) > 0
  -1.0 â‰¤ reward â‰¤ 1.0
  
  -- Postconditions
  experiences' = experiences âŒ¢ âŸ¨(description, reward)âŸ©
  
  -- Extract patterns if enough experiences
  length(experiences') â‰¥ PATTERN_EXTRACTION_THRESHOLD âŸ¹
    learnedPatterns' = learnedPatterns âˆª extract_patterns(experiences')

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
SECTION 7: LLM CLIENT OPERATIONS
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

â”Œâ”€ InitializeWebLLM â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Initializes WebLLM engine and loads model                                   â”‚
â”‚ Pre: Model is valid, not already initialized                                â”‚
â”‚ Post: Model loaded into WebGPU, ready for inference                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

[InitializeWebLLM]
  Î”WebLLMState
  Î”ConfigStore
  
  -- Preconditions
  webllmState.initialized = false
  valid_model(configStore.config.modelConfig.model)
  
  -- Operation (side effects: downloads model, initializes WebGPU)
  let model = configStore.config.modelConfig.model
  load_model_to_webgpu(model, configStore.config.cacheType)
  
  -- Postconditions
  webllmState'.initialized = true
  webllmState'.currentModel = model
  webllmState'.modelCache = webllmState.modelCache âˆª {model}
  webllmState'.isGenerating = false

â”Œâ”€ GenerateCompletion â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Generates LLM completion (streaming or non-streaming)                       â”‚
â”‚ Pre: Client initialized, not currently generating                           â”‚
â”‚ Post: Response streamed to chat session                                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

[GenerateCompletion]
  Î”SystemState
  messages: seq RequestMessage
  stream: ğ”¹
  
  -- Preconditions
  (configStore.config.modelClientType = WEBLLM âŸ¹ webllmState.initialized = true) âˆ§
  (configStore.config.modelClientType = MLCLLM_API âŸ¹ mlcllmState.connected = true)
  
  chatStore.sessions[chatStore.currentSessionIndex].isGenerating = false
  length(messages) > 0
  
  -- Operation (complex - involves streaming callbacks)
  let config = configStore.config.modelConfig
  
  stream = true âŸ¹
    -- Streaming: multiple calls to StreamAssistantMessage
    for chunk in generate_stream(messages, config) do
      StreamAssistantMessage(chunk)
  
  stream = false âŸ¹
    -- Non-streaming: single call
    let response = generate_complete(messages, config)
    StreamAssistantMessage(response)
  
  -- Postconditions
  (configStore.config.modelClientType = WEBLLM âŸ¹ webllmState'.isGenerating = false) âˆ§
  (configStore.config.modelClientType = MLCLLM_API âŸ¹ mlcllmState'.isGenerating = false)
  
  chatStore'.sessions[chatStore.currentSessionIndex].isGenerating = false

â”Œâ”€ AbortGeneration â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Aborts an ongoing LLM generation                                            â”‚
â”‚ Pre: Generation is in progress                                              â”‚
â”‚ Post: Generation stopped, message finalized                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

[AbortGeneration]
  Î”SystemState
  
  -- Preconditions
  chatStore.sessions[chatStore.currentSessionIndex].isGenerating = true
  
  -- Operation
  abort_llm_generation()
  
  -- Postconditions
  webllmState'.isGenerating = false
  mlcllmState'.isGenerating = false
  
  CompleteAssistantMessage(
    stopReason := error,
    usage := null,
    model := configStore.config.modelConfig.model)

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
SECTION 8: HELPER FUNCTIONS
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

[Helper Functions]
  fresh_id: â†’ seq char
  current_time: â†’ â„•
  current_date_string: â†’ seq char
  find_session_index: seq char â†’ â„•
  remove_at: seq Î± Ã— â„• â†’ seq Î±
  update_stats: ChatStat Ã— ChatMessage â†’ ChatStat
  find_oldest_low_importance: seq MemoryEntry â†’ MemoryEntry
  position: MemoryEntry Ã— seq MemoryEntry â†’ â„•
  matches_pattern: AtomNode Ã— AtomNode â†’ ğ”¹
  matches_query: seq char Ã— seq char â†’ ğ”¹
  translate: seq char Ã— Format Ã— Format â†’ seq char
  is_applicable: seq char Ã— AtomNode Ã— AtomNode â†’ ğ”¹
  apply_rule: seq char Ã— AtomNode Ã— AtomNode â†’ AtomNode
  compute_truth_value: seq char Ã— TruthValue Ã— TruthValue â†’ TruthValue
  select_parents: seq (seq char Ã— â„) â†’ seq (seq char Ã— â„)
  crossover: seq (seq char Ã— â„) Ã— â„ â†’ seq (seq char Ã— â„)
  mutate: seq (seq char Ã— â„) Ã— â„ â†’ seq (seq char Ã— â„)
  evaluate_fitness: seq (seq char Ã— â„) â†’ seq (seq char Ã— â„)
  select_survivors: seq (seq char Ã— â„) â†’ seq (seq char Ã— â„)
  extract_patterns: seq (seq char Ã— â„) â†’ seq (seq char)
  load_model_to_webgpu: Model Ã— CacheType â†’ ()
  generate_stream: seq RequestMessage Ã— ModelConfig â†’ Stream(seq char)
  generate_complete: seq RequestMessage Ã— ModelConfig â†’ seq char
  abort_llm_generation: â†’ ()

[Constants]
  MAX_SESSIONS: â„•
  DEFAULT_TOPIC: seq char
  PATTERN_EXTRACTION_THRESHOLD: â„•

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
END OF OPERATIONS SPECIFICATION
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
